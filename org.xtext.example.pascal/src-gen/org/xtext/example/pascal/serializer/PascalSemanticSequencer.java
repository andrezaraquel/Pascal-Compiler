/*
 * generated by Xtext 2.11.0
 */
package org.xtext.example.pascal.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.example.pascal.pascal.Begin;
import org.xtext.example.pascal.pascal.PascalPackage;
import org.xtext.example.pascal.pascal.actual_function;
import org.xtext.example.pascal.pascal.actual_parameter;
import org.xtext.example.pascal.pascal.actual_parameter_list;
import org.xtext.example.pascal.pascal.actual_procedure;
import org.xtext.example.pascal.pascal.actual_value;
import org.xtext.example.pascal.pascal.actual_variable;
import org.xtext.example.pascal.pascal.any_character_except_quote;
import org.xtext.example.pascal.pascal.array_type;
import org.xtext.example.pascal.pascal.assignment_statement;
import org.xtext.example.pascal.pascal.base_type;
import org.xtext.example.pascal.pascal.block;
import org.xtext.example.pascal.pascal.bound_specification;
import org.xtext.example.pascal.pascal.case_label_list;
import org.xtext.example.pascal.pascal.case_limb;
import org.xtext.example.pascal.pascal.case_statement;
import org.xtext.example.pascal.pascal.compiler_defined_directives;
import org.xtext.example.pascal.pascal.compound_statement;
import org.xtext.example.pascal.pascal.conditional_statement;
import org.xtext.example.pascal.pascal.conformant_array_schema;
import org.xtext.example.pascal.pascal.constant;
import org.xtext.example.pascal.pascal.constant_definition;
import org.xtext.example.pascal.pascal.constant_definition_part;
import org.xtext.example.pascal.pascal.declaration_part;
import org.xtext.example.pascal.pascal.digit_sequence;
import org.xtext.example.pascal.pascal.directive;
import org.xtext.example.pascal.pascal.element_list;
import org.xtext.example.pascal.pascal.element_type;
import org.xtext.example.pascal.pascal.entire_variable;
import org.xtext.example.pascal.pascal.enumerated_type;
import org.xtext.example.pascal.pascal.expression;
import org.xtext.example.pascal.pascal.expression_list;
import org.xtext.example.pascal.pascal.factor;
import org.xtext.example.pascal.pascal.field_list;
import org.xtext.example.pascal.pascal.file_component_type;
import org.xtext.example.pascal.pascal.file_type;
import org.xtext.example.pascal.pascal.final_expression;
import org.xtext.example.pascal.pascal.fixed_part;
import org.xtext.example.pascal.pascal.for_statement;
import org.xtext.example.pascal.pascal.formal_parameter_list;
import org.xtext.example.pascal.pascal.formal_parameter_section;
import org.xtext.example.pascal.pascal.function_block;
import org.xtext.example.pascal.pascal.function_body;
import org.xtext.example.pascal.pascal.function_designator;
import org.xtext.example.pascal.pascal.function_heading;
import org.xtext.example.pascal.pascal.function_identification;
import org.xtext.example.pascal.pascal.function_parameter_section;
import org.xtext.example.pascal.pascal.goto_statement;
import org.xtext.example.pascal.pascal.identifier;
import org.xtext.example.pascal.pascal.identifier_list;
import org.xtext.example.pascal.pascal.if_statement;
import org.xtext.example.pascal.pascal.index_type;
import org.xtext.example.pascal.pascal.initial_expression;
import org.xtext.example.pascal.pascal.integer_number;
import org.xtext.example.pascal.pascal.label;
import org.xtext.example.pascal.pascal.label_declaration_part;
import org.xtext.example.pascal.pascal.lower_bound;
import org.xtext.example.pascal.pascal.number;
import org.xtext.example.pascal.pascal.ordinal_type_identifier;
import org.xtext.example.pascal.pascal.packed_conformant_array_schema;
import org.xtext.example.pascal.pascal.parameter_type;
import org.xtext.example.pascal.pascal.pointer_type;
import org.xtext.example.pascal.pascal.procedure_block;
import org.xtext.example.pascal.pascal.procedure_body;
import org.xtext.example.pascal.pascal.procedure_heading;
import org.xtext.example.pascal.pascal.procedure_identification;
import org.xtext.example.pascal.pascal.procedure_parameter_section;
import org.xtext.example.pascal.pascal.procedure_statement;
import org.xtext.example.pascal.pascal.program;
import org.xtext.example.pascal.pascal.program_heading;
import org.xtext.example.pascal.pascal.real_number;
import org.xtext.example.pascal.pascal.record_section;
import org.xtext.example.pascal.pascal.record_type;
import org.xtext.example.pascal.pascal.repeat_statement;
import org.xtext.example.pascal.pascal.repetitive_statement;
import org.xtext.example.pascal.pascal.result_type;
import org.xtext.example.pascal.pascal.scale_factor;
import org.xtext.example.pascal.pascal.set;
import org.xtext.example.pascal.pascal.set_type;
import org.xtext.example.pascal.pascal.simple_expression;
import org.xtext.example.pascal.pascal.simple_statement;
import org.xtext.example.pascal.pascal.simple_type;
import org.xtext.example.pascal.pascal.statement;
import org.xtext.example.pascal.pascal.statement_part;
import org.xtext.example.pascal.pascal.statement_sequence;
import org.xtext.example.pascal.pascal.string_character;
import org.xtext.example.pascal.pascal.strings;
import org.xtext.example.pascal.pascal.structured_statement;
import org.xtext.example.pascal.pascal.structured_type;
import org.xtext.example.pascal.pascal.subrange_type;
import org.xtext.example.pascal.pascal.tag_field;
import org.xtext.example.pascal.pascal.term;
import org.xtext.example.pascal.pascal.type;
import org.xtext.example.pascal.pascal.type_definition;
import org.xtext.example.pascal.pascal.type_definition_part;
import org.xtext.example.pascal.pascal.type_identifier;
import org.xtext.example.pascal.pascal.unpacked_conformant_array_schema;
import org.xtext.example.pascal.pascal.unpacked_structured_type;
import org.xtext.example.pascal.pascal.upper_bound;
import org.xtext.example.pascal.pascal.value_parameter_section;
import org.xtext.example.pascal.pascal.variable;
import org.xtext.example.pascal.pascal.variable_declaration;
import org.xtext.example.pascal.pascal.variable_declaration_part;
import org.xtext.example.pascal.pascal.variable_parameter_section;
import org.xtext.example.pascal.pascal.variant;
import org.xtext.example.pascal.pascal.variant_part;
import org.xtext.example.pascal.pascal.while_statement;
import org.xtext.example.pascal.pascal.with_statement;
import org.xtext.example.pascal.services.PascalGrammarAccess;

@SuppressWarnings("all")
public class PascalSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private PascalGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == PascalPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case PascalPackage.BEGIN:
				sequence_Begin(context, (Begin) semanticObject); 
				return; 
			case PascalPackage.ACTUAL_FUNCTION:
				sequence_actual_function(context, (actual_function) semanticObject); 
				return; 
			case PascalPackage.ACTUAL_PARAMETER:
				sequence_actual_parameter(context, (actual_parameter) semanticObject); 
				return; 
			case PascalPackage.ACTUAL_PARAMETER_LIST:
				sequence_actual_parameter_list(context, (actual_parameter_list) semanticObject); 
				return; 
			case PascalPackage.ACTUAL_PROCEDURE:
				sequence_actual_procedure(context, (actual_procedure) semanticObject); 
				return; 
			case PascalPackage.ACTUAL_VALUE:
				sequence_actual_value(context, (actual_value) semanticObject); 
				return; 
			case PascalPackage.ACTUAL_VARIABLE:
				sequence_actual_variable(context, (actual_variable) semanticObject); 
				return; 
			case PascalPackage.ANY_CHARACTER_EXCEPT_QUOTE:
				sequence_any_character_except_quote(context, (any_character_except_quote) semanticObject); 
				return; 
			case PascalPackage.ARRAY_TYPE:
				sequence_array_type(context, (array_type) semanticObject); 
				return; 
			case PascalPackage.ASSIGNMENT_STATEMENT:
				sequence_assignment_statement(context, (assignment_statement) semanticObject); 
				return; 
			case PascalPackage.BASE_TYPE:
				sequence_base_type(context, (base_type) semanticObject); 
				return; 
			case PascalPackage.BLOCK:
				sequence_block(context, (block) semanticObject); 
				return; 
			case PascalPackage.BOUND_SPECIFICATION:
				sequence_bound_specification(context, (bound_specification) semanticObject); 
				return; 
			case PascalPackage.CASE_LABEL_LIST:
				sequence_case_label_list(context, (case_label_list) semanticObject); 
				return; 
			case PascalPackage.CASE_LIMB:
				sequence_case_limb(context, (case_limb) semanticObject); 
				return; 
			case PascalPackage.CASE_STATEMENT:
				sequence_case_statement(context, (case_statement) semanticObject); 
				return; 
			case PascalPackage.COMPILER_DEFINED_DIRECTIVES:
				sequence_compiler_defined_directives(context, (compiler_defined_directives) semanticObject); 
				return; 
			case PascalPackage.COMPOUND_STATEMENT:
				sequence_compound_statement(context, (compound_statement) semanticObject); 
				return; 
			case PascalPackage.CONDITIONAL_STATEMENT:
				sequence_conditional_statement(context, (conditional_statement) semanticObject); 
				return; 
			case PascalPackage.CONFORMANT_ARRAY_SCHEMA:
				sequence_conformant_array_schema(context, (conformant_array_schema) semanticObject); 
				return; 
			case PascalPackage.CONSTANT:
				sequence_constant(context, (constant) semanticObject); 
				return; 
			case PascalPackage.CONSTANT_DEFINITION:
				sequence_constant_definition(context, (constant_definition) semanticObject); 
				return; 
			case PascalPackage.CONSTANT_DEFINITION_PART:
				sequence_constant_definition_part(context, (constant_definition_part) semanticObject); 
				return; 
			case PascalPackage.DECLARATION_PART:
				sequence_declaration_part(context, (declaration_part) semanticObject); 
				return; 
			case PascalPackage.DIGIT_SEQUENCE:
				sequence_digit_sequence(context, (digit_sequence) semanticObject); 
				return; 
			case PascalPackage.DIRECTIVE:
				sequence_directive(context, (directive) semanticObject); 
				return; 
			case PascalPackage.ELEMENT_LIST:
				sequence_element_list(context, (element_list) semanticObject); 
				return; 
			case PascalPackage.ELEMENT_TYPE:
				sequence_element_type(context, (element_type) semanticObject); 
				return; 
			case PascalPackage.ENTIRE_VARIABLE:
				sequence_entire_variable(context, (entire_variable) semanticObject); 
				return; 
			case PascalPackage.ENUMERATED_TYPE:
				sequence_enumerated_type(context, (enumerated_type) semanticObject); 
				return; 
			case PascalPackage.EXPRESSION:
				if (rule == grammarAccess.getExpressionRule()) {
					sequence_expression(context, (expression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getOutput_listRule()) {
					sequence_expression_output_list_output_value(context, (expression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getOutput_valueRule()) {
					sequence_expression_output_value(context, (expression) semanticObject); 
					return; 
				}
				else break;
			case PascalPackage.EXPRESSION_LIST:
				sequence_expression_list(context, (expression_list) semanticObject); 
				return; 
			case PascalPackage.FACTOR:
				sequence_factor(context, (factor) semanticObject); 
				return; 
			case PascalPackage.FIELD_LIST:
				sequence_field_list(context, (field_list) semanticObject); 
				return; 
			case PascalPackage.FILE_COMPONENT_TYPE:
				sequence_file_component_type(context, (file_component_type) semanticObject); 
				return; 
			case PascalPackage.FILE_TYPE:
				sequence_file_type(context, (file_type) semanticObject); 
				return; 
			case PascalPackage.FINAL_EXPRESSION:
				sequence_final_expression(context, (final_expression) semanticObject); 
				return; 
			case PascalPackage.FIXED_PART:
				sequence_fixed_part(context, (fixed_part) semanticObject); 
				return; 
			case PascalPackage.FOR_STATEMENT:
				sequence_for_statement(context, (for_statement) semanticObject); 
				return; 
			case PascalPackage.FORMAL_PARAMETER_LIST:
				sequence_formal_parameter_list(context, (formal_parameter_list) semanticObject); 
				return; 
			case PascalPackage.FORMAL_PARAMETER_SECTION:
				sequence_formal_parameter_section(context, (formal_parameter_section) semanticObject); 
				return; 
			case PascalPackage.FUNCTION_BLOCK:
				sequence_function_block(context, (function_block) semanticObject); 
				return; 
			case PascalPackage.FUNCTION_BODY:
				sequence_function_body(context, (function_body) semanticObject); 
				return; 
			case PascalPackage.FUNCTION_DESIGNATOR:
				sequence_function_designator(context, (function_designator) semanticObject); 
				return; 
			case PascalPackage.FUNCTION_HEADING:
				sequence_function_heading(context, (function_heading) semanticObject); 
				return; 
			case PascalPackage.FUNCTION_IDENTIFICATION:
				sequence_function_identification(context, (function_identification) semanticObject); 
				return; 
			case PascalPackage.FUNCTION_PARAMETER_SECTION:
				sequence_function_parameter_section(context, (function_parameter_section) semanticObject); 
				return; 
			case PascalPackage.GOTO_STATEMENT:
				sequence_goto_statement(context, (goto_statement) semanticObject); 
				return; 
			case PascalPackage.IDENTIFIER:
				sequence_identifier(context, (identifier) semanticObject); 
				return; 
			case PascalPackage.IDENTIFIER_LIST:
				sequence_identifier_list(context, (identifier_list) semanticObject); 
				return; 
			case PascalPackage.IF_STATEMENT:
				sequence_if_statement(context, (if_statement) semanticObject); 
				return; 
			case PascalPackage.INDEX_TYPE:
				sequence_index_type(context, (index_type) semanticObject); 
				return; 
			case PascalPackage.INITIAL_EXPRESSION:
				sequence_initial_expression(context, (initial_expression) semanticObject); 
				return; 
			case PascalPackage.INTEGER_NUMBER:
				sequence_integer_number(context, (integer_number) semanticObject); 
				return; 
			case PascalPackage.LABEL:
				sequence_label(context, (label) semanticObject); 
				return; 
			case PascalPackage.LABEL_DECLARATION_PART:
				sequence_label_declaration_part(context, (label_declaration_part) semanticObject); 
				return; 
			case PascalPackage.LOWER_BOUND:
				sequence_lower_bound(context, (lower_bound) semanticObject); 
				return; 
			case PascalPackage.NUMBER:
				sequence_number(context, (number) semanticObject); 
				return; 
			case PascalPackage.ORDINAL_TYPE_IDENTIFIER:
				sequence_ordinal_type_identifier(context, (ordinal_type_identifier) semanticObject); 
				return; 
			case PascalPackage.PACKED_CONFORMANT_ARRAY_SCHEMA:
				sequence_packed_conformant_array_schema(context, (packed_conformant_array_schema) semanticObject); 
				return; 
			case PascalPackage.PARAMETER_TYPE:
				sequence_parameter_type(context, (parameter_type) semanticObject); 
				return; 
			case PascalPackage.POINTER_TYPE:
				sequence_pointer_type(context, (pointer_type) semanticObject); 
				return; 
			case PascalPackage.PROCEDURE_BLOCK:
				sequence_procedure_block(context, (procedure_block) semanticObject); 
				return; 
			case PascalPackage.PROCEDURE_BODY:
				sequence_procedure_body(context, (procedure_body) semanticObject); 
				return; 
			case PascalPackage.PROCEDURE_HEADING:
				sequence_procedure_heading(context, (procedure_heading) semanticObject); 
				return; 
			case PascalPackage.PROCEDURE_IDENTIFICATION:
				sequence_procedure_identification(context, (procedure_identification) semanticObject); 
				return; 
			case PascalPackage.PROCEDURE_PARAMETER_SECTION:
				sequence_procedure_parameter_section(context, (procedure_parameter_section) semanticObject); 
				return; 
			case PascalPackage.PROCEDURE_STATEMENT:
				sequence_procedure_statement(context, (procedure_statement) semanticObject); 
				return; 
			case PascalPackage.PROGRAM:
				sequence_program(context, (program) semanticObject); 
				return; 
			case PascalPackage.PROGRAM_HEADING:
				sequence_program_heading(context, (program_heading) semanticObject); 
				return; 
			case PascalPackage.REAL_NUMBER:
				sequence_real_number(context, (real_number) semanticObject); 
				return; 
			case PascalPackage.RECORD_SECTION:
				sequence_record_section(context, (record_section) semanticObject); 
				return; 
			case PascalPackage.RECORD_TYPE:
				sequence_record_type(context, (record_type) semanticObject); 
				return; 
			case PascalPackage.REPEAT_STATEMENT:
				sequence_repeat_statement(context, (repeat_statement) semanticObject); 
				return; 
			case PascalPackage.REPETITIVE_STATEMENT:
				sequence_repetitive_statement(context, (repetitive_statement) semanticObject); 
				return; 
			case PascalPackage.RESULT_TYPE:
				sequence_result_type(context, (result_type) semanticObject); 
				return; 
			case PascalPackage.SCALE_FACTOR:
				sequence_scale_factor(context, (scale_factor) semanticObject); 
				return; 
			case PascalPackage.SET:
				sequence_set(context, (set) semanticObject); 
				return; 
			case PascalPackage.SET_TYPE:
				sequence_set_type(context, (set_type) semanticObject); 
				return; 
			case PascalPackage.SIMPLE_EXPRESSION:
				sequence_simple_expression(context, (simple_expression) semanticObject); 
				return; 
			case PascalPackage.SIMPLE_STATEMENT:
				sequence_simple_statement(context, (simple_statement) semanticObject); 
				return; 
			case PascalPackage.SIMPLE_TYPE:
				sequence_simple_type(context, (simple_type) semanticObject); 
				return; 
			case PascalPackage.STATEMENT:
				sequence_statement(context, (statement) semanticObject); 
				return; 
			case PascalPackage.STATEMENT_PART:
				sequence_statement_part(context, (statement_part) semanticObject); 
				return; 
			case PascalPackage.STATEMENT_SEQUENCE:
				sequence_statement_sequence(context, (statement_sequence) semanticObject); 
				return; 
			case PascalPackage.STRING_CHARACTER:
				sequence_string_character(context, (string_character) semanticObject); 
				return; 
			case PascalPackage.STRINGS:
				sequence_strings(context, (strings) semanticObject); 
				return; 
			case PascalPackage.STRUCTURED_STATEMENT:
				sequence_structured_statement(context, (structured_statement) semanticObject); 
				return; 
			case PascalPackage.STRUCTURED_TYPE:
				sequence_structured_type(context, (structured_type) semanticObject); 
				return; 
			case PascalPackage.SUBRANGE_TYPE:
				sequence_subrange_type(context, (subrange_type) semanticObject); 
				return; 
			case PascalPackage.TAG_FIELD:
				sequence_tag_field(context, (tag_field) semanticObject); 
				return; 
			case PascalPackage.TERM:
				sequence_term(context, (term) semanticObject); 
				return; 
			case PascalPackage.TYPE:
				sequence_type(context, (type) semanticObject); 
				return; 
			case PascalPackage.TYPE_DEFINITION:
				sequence_type_definition(context, (type_definition) semanticObject); 
				return; 
			case PascalPackage.TYPE_DEFINITION_PART:
				sequence_type_definition_part(context, (type_definition_part) semanticObject); 
				return; 
			case PascalPackage.TYPE_IDENTIFIER:
				sequence_type_identifier(context, (type_identifier) semanticObject); 
				return; 
			case PascalPackage.UNPACKED_CONFORMANT_ARRAY_SCHEMA:
				sequence_unpacked_conformant_array_schema(context, (unpacked_conformant_array_schema) semanticObject); 
				return; 
			case PascalPackage.UNPACKED_STRUCTURED_TYPE:
				sequence_unpacked_structured_type(context, (unpacked_structured_type) semanticObject); 
				return; 
			case PascalPackage.UPPER_BOUND:
				sequence_upper_bound(context, (upper_bound) semanticObject); 
				return; 
			case PascalPackage.VALUE_PARAMETER_SECTION:
				sequence_value_parameter_section(context, (value_parameter_section) semanticObject); 
				return; 
			case PascalPackage.VARIABLE:
				sequence_variable(context, (variable) semanticObject); 
				return; 
			case PascalPackage.VARIABLE_DECLARATION:
				sequence_variable_declaration(context, (variable_declaration) semanticObject); 
				return; 
			case PascalPackage.VARIABLE_DECLARATION_PART:
				sequence_variable_declaration_part(context, (variable_declaration_part) semanticObject); 
				return; 
			case PascalPackage.VARIABLE_PARAMETER_SECTION:
				sequence_variable_parameter_section(context, (variable_parameter_section) semanticObject); 
				return; 
			case PascalPackage.VARIANT:
				sequence_variant(context, (variant) semanticObject); 
				return; 
			case PascalPackage.VARIANT_PART:
				sequence_variant_part(context, (variant_part) semanticObject); 
				return; 
			case PascalPackage.WHILE_STATEMENT:
				sequence_while_statement(context, (while_statement) semanticObject); 
				return; 
			case PascalPackage.WITH_STATEMENT:
				sequence_with_statement(context, (with_statement) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Begin returns Begin
	 *
	 * Constraint:
	 *     elements+=program
	 */
	protected void sequence_Begin(ISerializationContext context, Begin semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     actual_function returns actual_function
	 *
	 * Constraint:
	 *     function_identifier=identifier
	 */
	protected void sequence_actual_function(ISerializationContext context, actual_function semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PascalPackage.Literals.ACTUAL_FUNCTION__FUNCTION_IDENTIFIER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalPackage.Literals.ACTUAL_FUNCTION__FUNCTION_IDENTIFIER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getActual_functionAccess().getFunction_identifierIdentifierParserRuleCall_0(), semanticObject.getFunction_identifier());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     actual_parameter returns actual_parameter
	 *
	 * Constraint:
	 *     (actual_value=actual_value | actual_variable=actual_variable | actual_procedure=actual_procedure | actual_function=actual_function)
	 */
	protected void sequence_actual_parameter(ISerializationContext context, actual_parameter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     actual_parameter_list returns actual_parameter_list
	 *
	 * Constraint:
	 *     (actual_parameter+=actual_parameter actual_parameter+=actual_parameter*)
	 */
	protected void sequence_actual_parameter_list(ISerializationContext context, actual_parameter_list semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     actual_procedure returns actual_procedure
	 *
	 * Constraint:
	 *     procedure_identifier=identifier
	 */
	protected void sequence_actual_procedure(ISerializationContext context, actual_procedure semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PascalPackage.Literals.ACTUAL_PROCEDURE__PROCEDURE_IDENTIFIER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalPackage.Literals.ACTUAL_PROCEDURE__PROCEDURE_IDENTIFIER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getActual_procedureAccess().getProcedure_identifierIdentifierParserRuleCall_0(), semanticObject.getProcedure_identifier());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     actual_value returns actual_value
	 *
	 * Constraint:
	 *     expression=expression
	 */
	protected void sequence_actual_value(ISerializationContext context, actual_value semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PascalPackage.Literals.ACTUAL_VALUE__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalPackage.Literals.ACTUAL_VALUE__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getActual_valueAccess().getExpressionExpressionParserRuleCall_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     actual_variable returns actual_variable
	 *
	 * Constraint:
	 *     variable=variable
	 */
	protected void sequence_actual_variable(ISerializationContext context, actual_variable semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PascalPackage.Literals.ACTUAL_VARIABLE__VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalPackage.Literals.ACTUAL_VARIABLE__VARIABLE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getActual_variableAccess().getVariableVariableParserRuleCall_0(), semanticObject.getVariable());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     any_character_except_quote returns any_character_except_quote
	 *
	 * Constraint:
	 *     procedure_heading=procedure_heading
	 */
	protected void sequence_any_character_except_quote(ISerializationContext context, any_character_except_quote semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PascalPackage.Literals.ANY_CHARACTER_EXCEPT_QUOTE__PROCEDURE_HEADING) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalPackage.Literals.ANY_CHARACTER_EXCEPT_QUOTE__PROCEDURE_HEADING));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAny_character_except_quoteAccess().getProcedure_headingProcedure_headingParserRuleCall_0(), semanticObject.getProcedure_heading());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     array_type returns array_type
	 *
	 * Constraint:
	 *     (index_type+=index_type index_type+=index_type* element_type=element_type)
	 */
	protected void sequence_array_type(ISerializationContext context, array_type semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     assignment_statement returns assignment_statement
	 *
	 * Constraint:
	 *     ((variable=variable | function_identifier=identifier) expression=expression)
	 */
	protected void sequence_assignment_statement(ISerializationContext context, assignment_statement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     base_type returns base_type
	 *
	 * Constraint:
	 *     type=type
	 */
	protected void sequence_base_type(ISerializationContext context, base_type semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PascalPackage.Literals.BASE_TYPE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalPackage.Literals.BASE_TYPE__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBase_typeAccess().getTypeTypeParserRuleCall_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     block returns block
	 *
	 * Constraint:
	 *     (declaration_part=declaration_part statement_part=statement_part)
	 */
	protected void sequence_block(ISerializationContext context, block semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PascalPackage.Literals.BLOCK__DECLARATION_PART) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalPackage.Literals.BLOCK__DECLARATION_PART));
			if (transientValues.isValueTransient(semanticObject, PascalPackage.Literals.BLOCK__STATEMENT_PART) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalPackage.Literals.BLOCK__STATEMENT_PART));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBlockAccess().getDeclaration_partDeclaration_partParserRuleCall_0_0(), semanticObject.getDeclaration_part());
		feeder.accept(grammarAccess.getBlockAccess().getStatement_partStatement_partParserRuleCall_1_0(), semanticObject.getStatement_part());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     bound_specification returns bound_specification
	 *
	 * Constraint:
	 *     (identifier=identifier identifier2=identifier ordinal_type_identifier=ordinal_type_identifier)
	 */
	protected void sequence_bound_specification(ISerializationContext context, bound_specification semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PascalPackage.Literals.BOUND_SPECIFICATION__IDENTIFIER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalPackage.Literals.BOUND_SPECIFICATION__IDENTIFIER));
			if (transientValues.isValueTransient(semanticObject, PascalPackage.Literals.BOUND_SPECIFICATION__IDENTIFIER2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalPackage.Literals.BOUND_SPECIFICATION__IDENTIFIER2));
			if (transientValues.isValueTransient(semanticObject, PascalPackage.Literals.BOUND_SPECIFICATION__ORDINAL_TYPE_IDENTIFIER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalPackage.Literals.BOUND_SPECIFICATION__ORDINAL_TYPE_IDENTIFIER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBound_specificationAccess().getIdentifierIdentifierParserRuleCall_0_0(), semanticObject.getIdentifier());
		feeder.accept(grammarAccess.getBound_specificationAccess().getIdentifier2IdentifierParserRuleCall_2_0(), semanticObject.getIdentifier2());
		feeder.accept(grammarAccess.getBound_specificationAccess().getOrdinal_type_identifierOrdinal_type_identifierParserRuleCall_4_0(), semanticObject.getOrdinal_type_identifier());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     case_label_list returns case_label_list
	 *
	 * Constraint:
	 *     (constant+=constant constant+=constant*)
	 */
	protected void sequence_case_label_list(ISerializationContext context, case_label_list semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     case_limb returns case_limb
	 *
	 * Constraint:
	 *     (case_label_list=case_label_list statement=statement)
	 */
	protected void sequence_case_limb(ISerializationContext context, case_limb semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PascalPackage.Literals.CASE_LIMB__CASE_LABEL_LIST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalPackage.Literals.CASE_LIMB__CASE_LABEL_LIST));
			if (transientValues.isValueTransient(semanticObject, PascalPackage.Literals.CASE_LIMB__STATEMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalPackage.Literals.CASE_LIMB__STATEMENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCase_limbAccess().getCase_label_listCase_label_listParserRuleCall_0_0(), semanticObject.getCase_label_list());
		feeder.accept(grammarAccess.getCase_limbAccess().getStatementStatementParserRuleCall_2_0(), semanticObject.getStatement());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     case_statement returns case_statement
	 *
	 * Constraint:
	 *     (expression=expression case_limb+=case_limb case_limb+=case_limb*)
	 */
	protected void sequence_case_statement(ISerializationContext context, case_statement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     compiler_defined_directives returns compiler_defined_directives
	 *
	 * Constraint:
	 *     procedure_heading=procedure_heading
	 */
	protected void sequence_compiler_defined_directives(ISerializationContext context, compiler_defined_directives semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PascalPackage.Literals.COMPILER_DEFINED_DIRECTIVES__PROCEDURE_HEADING) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalPackage.Literals.COMPILER_DEFINED_DIRECTIVES__PROCEDURE_HEADING));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCompiler_defined_directivesAccess().getProcedure_headingProcedure_headingParserRuleCall_0(), semanticObject.getProcedure_heading());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     compound_statement returns compound_statement
	 *
	 * Constraint:
	 *     statement_sequence=statement_sequence
	 */
	protected void sequence_compound_statement(ISerializationContext context, compound_statement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PascalPackage.Literals.COMPOUND_STATEMENT__STATEMENT_SEQUENCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalPackage.Literals.COMPOUND_STATEMENT__STATEMENT_SEQUENCE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCompound_statementAccess().getStatement_sequenceStatement_sequenceParserRuleCall_1_0(), semanticObject.getStatement_sequence());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     conditional_statement returns conditional_statement
	 *
	 * Constraint:
	 *     (if_statement=if_statement | case_statement=case_statement)
	 */
	protected void sequence_conditional_statement(ISerializationContext context, conditional_statement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     conformant_array_schema returns conformant_array_schema
	 *
	 * Constraint:
	 *     (packed_conformant_array_schema=packed_conformant_array_schema | unpacked_conformant_array_schema=unpacked_conformant_array_schema)
	 */
	protected void sequence_conformant_array_schema(ISerializationContext context, conformant_array_schema semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     constant returns constant
	 *
	 * Constraint:
	 *     ((sign=sign? (constant_identifier=identifier | number=number)) | strings=strings)
	 */
	protected void sequence_constant(ISerializationContext context, constant semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     constant_definition returns constant_definition
	 *
	 * Constraint:
	 *     (identifier=identifier constant=constant)
	 */
	protected void sequence_constant_definition(ISerializationContext context, constant_definition semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PascalPackage.Literals.CONSTANT_DEFINITION__IDENTIFIER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalPackage.Literals.CONSTANT_DEFINITION__IDENTIFIER));
			if (transientValues.isValueTransient(semanticObject, PascalPackage.Literals.CONSTANT_DEFINITION__CONSTANT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalPackage.Literals.CONSTANT_DEFINITION__CONSTANT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConstant_definitionAccess().getIdentifierIdentifierParserRuleCall_0_0(), semanticObject.getIdentifier());
		feeder.accept(grammarAccess.getConstant_definitionAccess().getConstantConstantParserRuleCall_2_0(), semanticObject.getConstant());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     constant_definition_part returns constant_definition_part
	 *
	 * Constraint:
	 *     (constant_definition+=constant_definition constant_definition+=constant_definition*)
	 */
	protected void sequence_constant_definition_part(ISerializationContext context, constant_definition_part semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     declaration_part returns declaration_part
	 *
	 * Constraint:
	 *     (
	 *         label_declaration_part=label_declaration_part? 
	 *         constant_definition_part=constant_definition_part? 
	 *         type_definition_part=type_definition_part? 
	 *         variable_declaration_part=variable_declaration_part? 
	 *         (
	 *             (procedure_heading+=procedure_heading procedure_body+=procedure_body) | 
	 *             (procedure_heading+=procedure_heading directive+=directive) | 
	 *             (procedure_identification+=procedure_identification procedure_body+=procedure_body) | 
	 *             (function_heading+=function_heading function_body+=function_body) | 
	 *             (function_heading+=function_heading directive+=directive) | 
	 *             (function_identification+=function_identification function_body+=function_body)
	 *         )*
	 *     )
	 */
	protected void sequence_declaration_part(ISerializationContext context, declaration_part semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     digit_sequence returns digit_sequence
	 *
	 * Constraint:
	 *     (sign=sign? unsigned_digit_sequence=unsigned_digit_sequence)
	 */
	protected void sequence_digit_sequence(ISerializationContext context, digit_sequence semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     directive returns directive
	 *
	 * Constraint:
	 *     compiler_defined_directives=compiler_defined_directives?
	 */
	protected void sequence_directive(ISerializationContext context, directive semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     element_list returns element_list
	 *
	 * Constraint:
	 *     (expression+=expression expression+=expression*)?
	 */
	protected void sequence_element_list(ISerializationContext context, element_list semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     element_type returns element_type
	 *
	 * Constraint:
	 *     type=type
	 */
	protected void sequence_element_type(ISerializationContext context, element_type semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PascalPackage.Literals.ELEMENT_TYPE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalPackage.Literals.ELEMENT_TYPE__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getElement_typeAccess().getTypeTypeParserRuleCall_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     entire_variable returns entire_variable
	 *
	 * Constraint:
	 *     identifier=identifier
	 */
	protected void sequence_entire_variable(ISerializationContext context, entire_variable semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PascalPackage.Literals.ENTIRE_VARIABLE__IDENTIFIER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalPackage.Literals.ENTIRE_VARIABLE__IDENTIFIER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEntire_variableAccess().getIdentifierIdentifierParserRuleCall_0(), semanticObject.getIdentifier());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     enumerated_type returns enumerated_type
	 *
	 * Constraint:
	 *     identifier_list=identifier_list
	 */
	protected void sequence_enumerated_type(ISerializationContext context, enumerated_type semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PascalPackage.Literals.ENUMERATED_TYPE__IDENTIFIER_LIST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalPackage.Literals.ENUMERATED_TYPE__IDENTIFIER_LIST));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEnumerated_typeAccess().getIdentifier_listIdentifier_listParserRuleCall_1_0(), semanticObject.getIdentifier_list());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     expression returns expression
	 *
	 * Constraint:
	 *     (simple_expression+=simple_expression (relational_operator=relational_operator simple_expression+=simple_expression)?)
	 */
	protected void sequence_expression(ISerializationContext context, expression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     expression_list returns expression_list
	 *
	 * Constraint:
	 *     (expression+=expression expression+=expression*)
	 */
	protected void sequence_expression_list(ISerializationContext context, expression_list semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     output_list returns expression
	 *
	 * Constraint:
	 *     (
	 *         simple_expression+=simple_expression 
	 *         (relational_operator=relational_operator simple_expression+=simple_expression)? 
	 *         (expression+=expression expression+=expression?)? 
	 *         output_value+=output_value*
	 *     )
	 */
	protected void sequence_expression_output_list_output_value(ISerializationContext context, expression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     output_value returns expression
	 *
	 * Constraint:
	 *     (
	 *         simple_expression+=simple_expression 
	 *         (relational_operator=relational_operator simple_expression+=simple_expression)? 
	 *         (expression+=expression expression+=expression?)?
	 *     )
	 */
	protected void sequence_expression_output_value(ISerializationContext context, expression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     factor returns factor
	 *
	 * Constraint:
	 *     (
	 *         variable=variable | 
	 *         number=number | 
	 *         strings=strings | 
	 *         set=set | 
	 *         identifier=identifier | 
	 *         function_designator=function_designator | 
	 *         expression=expression | 
	 *         factor=factor
	 *     )
	 */
	protected void sequence_factor(ISerializationContext context, factor semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     field_list returns field_list
	 *
	 * Constraint:
	 *     ((fixed_part=fixed_part variant_part=variant_part?) | variant_part=variant_part)?
	 */
	protected void sequence_field_list(ISerializationContext context, field_list semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     file_component_type returns file_component_type
	 *
	 * Constraint:
	 *     type=type
	 */
	protected void sequence_file_component_type(ISerializationContext context, file_component_type semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PascalPackage.Literals.FILE_COMPONENT_TYPE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalPackage.Literals.FILE_COMPONENT_TYPE__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFile_component_typeAccess().getTypeTypeParserRuleCall_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     file_type returns file_type
	 *
	 * Constraint:
	 *     file_component_type=file_component_type
	 */
	protected void sequence_file_type(ISerializationContext context, file_type semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PascalPackage.Literals.FILE_TYPE__FILE_COMPONENT_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalPackage.Literals.FILE_TYPE__FILE_COMPONENT_TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFile_typeAccess().getFile_component_typeFile_component_typeParserRuleCall_2_0(), semanticObject.getFile_component_type());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     final_expression returns final_expression
	 *
	 * Constraint:
	 *     expression=expression
	 */
	protected void sequence_final_expression(ISerializationContext context, final_expression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PascalPackage.Literals.FINAL_EXPRESSION__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalPackage.Literals.FINAL_EXPRESSION__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFinal_expressionAccess().getExpressionExpressionParserRuleCall_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     fixed_part returns fixed_part
	 *
	 * Constraint:
	 *     (record_section+=record_section record_section+=record_section*)
	 */
	protected void sequence_fixed_part(ISerializationContext context, fixed_part semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     for_statement returns for_statement
	 *
	 * Constraint:
	 *     (variable_identifier=identifier initial_expression=initial_expression final_expression=final_expression statement=statement)
	 */
	protected void sequence_for_statement(ISerializationContext context, for_statement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PascalPackage.Literals.FOR_STATEMENT__VARIABLE_IDENTIFIER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalPackage.Literals.FOR_STATEMENT__VARIABLE_IDENTIFIER));
			if (transientValues.isValueTransient(semanticObject, PascalPackage.Literals.FOR_STATEMENT__INITIAL_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalPackage.Literals.FOR_STATEMENT__INITIAL_EXPRESSION));
			if (transientValues.isValueTransient(semanticObject, PascalPackage.Literals.FOR_STATEMENT__FINAL_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalPackage.Literals.FOR_STATEMENT__FINAL_EXPRESSION));
			if (transientValues.isValueTransient(semanticObject, PascalPackage.Literals.FOR_STATEMENT__STATEMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalPackage.Literals.FOR_STATEMENT__STATEMENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFor_statementAccess().getVariable_identifierIdentifierParserRuleCall_1_0(), semanticObject.getVariable_identifier());
		feeder.accept(grammarAccess.getFor_statementAccess().getInitial_expressionInitial_expressionParserRuleCall_3_0(), semanticObject.getInitial_expression());
		feeder.accept(grammarAccess.getFor_statementAccess().getFinal_expressionFinal_expressionParserRuleCall_5_0(), semanticObject.getFinal_expression());
		feeder.accept(grammarAccess.getFor_statementAccess().getStatementStatementParserRuleCall_7_0(), semanticObject.getStatement());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     formal_parameter_list returns formal_parameter_list
	 *
	 * Constraint:
	 *     (formal_parameter_section+=formal_parameter_section formal_parameter_section+=formal_parameter_section*)
	 */
	protected void sequence_formal_parameter_list(ISerializationContext context, formal_parameter_list semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     formal_parameter_section returns formal_parameter_section
	 *
	 * Constraint:
	 *     (
	 *         value_parameter_section=value_parameter_section | 
	 *         variable_parameter_section=variable_parameter_section | 
	 *         procedure_parameter_section=procedure_parameter_section | 
	 *         function_parameter_section=function_parameter_section
	 *     )
	 */
	protected void sequence_formal_parameter_section(ISerializationContext context, formal_parameter_section semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     function_block returns function_block
	 *
	 * Constraint:
	 *     (declaration_part=declaration_part statement_part=statement_part)
	 */
	protected void sequence_function_block(ISerializationContext context, function_block semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PascalPackage.Literals.FUNCTION_BLOCK__DECLARATION_PART) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalPackage.Literals.FUNCTION_BLOCK__DECLARATION_PART));
			if (transientValues.isValueTransient(semanticObject, PascalPackage.Literals.FUNCTION_BLOCK__STATEMENT_PART) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalPackage.Literals.FUNCTION_BLOCK__STATEMENT_PART));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFunction_blockAccess().getDeclaration_partDeclaration_partParserRuleCall_0_0(), semanticObject.getDeclaration_part());
		feeder.accept(grammarAccess.getFunction_blockAccess().getStatement_partStatement_partParserRuleCall_1_0(), semanticObject.getStatement_part());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     function_body returns function_body
	 *
	 * Constraint:
	 *     function_block=function_block
	 */
	protected void sequence_function_body(ISerializationContext context, function_body semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PascalPackage.Literals.FUNCTION_BODY__FUNCTION_BLOCK) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalPackage.Literals.FUNCTION_BODY__FUNCTION_BLOCK));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFunction_bodyAccess().getFunction_blockFunction_blockParserRuleCall_0(), semanticObject.getFunction_block());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     function_designator returns function_designator
	 *
	 * Constraint:
	 *     (function_identifier=identifier actual_parameter_list=actual_parameter_list?)
	 */
	protected void sequence_function_designator(ISerializationContext context, function_designator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     function_heading returns function_heading
	 *
	 * Constraint:
	 *     (identifier=identifier formal_parameter_list=formal_parameter_list? result_type=result_type)
	 */
	protected void sequence_function_heading(ISerializationContext context, function_heading semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     function_identification returns function_identification
	 *
	 * Constraint:
	 *     function_identifier=identifier
	 */
	protected void sequence_function_identification(ISerializationContext context, function_identification semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PascalPackage.Literals.FUNCTION_IDENTIFICATION__FUNCTION_IDENTIFIER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalPackage.Literals.FUNCTION_IDENTIFICATION__FUNCTION_IDENTIFIER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFunction_identificationAccess().getFunction_identifierIdentifierParserRuleCall_1_0(), semanticObject.getFunction_identifier());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     function_parameter_section returns function_parameter_section
	 *
	 * Constraint:
	 *     function_heading=function_heading
	 */
	protected void sequence_function_parameter_section(ISerializationContext context, function_parameter_section semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PascalPackage.Literals.FUNCTION_PARAMETER_SECTION__FUNCTION_HEADING) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalPackage.Literals.FUNCTION_PARAMETER_SECTION__FUNCTION_HEADING));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFunction_parameter_sectionAccess().getFunction_headingFunction_headingParserRuleCall_0(), semanticObject.getFunction_heading());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     goto_statement returns goto_statement
	 *
	 * Constraint:
	 *     label=label
	 */
	protected void sequence_goto_statement(ISerializationContext context, goto_statement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PascalPackage.Literals.GOTO_STATEMENT__LABEL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalPackage.Literals.GOTO_STATEMENT__LABEL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getGoto_statementAccess().getLabelLabelParserRuleCall_1_0(), semanticObject.getLabel());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     identifier returns identifier
	 *
	 * Constraint:
	 *     identifier=ID
	 */
	protected void sequence_identifier(ISerializationContext context, identifier semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PascalPackage.Literals.IDENTIFIER__IDENTIFIER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalPackage.Literals.IDENTIFIER__IDENTIFIER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIdentifierAccess().getIdentifierIDTerminalRuleCall_0(), semanticObject.getIdentifier());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     identifier_list returns identifier_list
	 *
	 * Constraint:
	 *     (identifier+=ID identifier+=ID*)
	 */
	protected void sequence_identifier_list(ISerializationContext context, identifier_list semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     if_statement returns if_statement
	 *
	 * Constraint:
	 *     (expression=expression statement+=statement statement+=statement?)
	 */
	protected void sequence_if_statement(ISerializationContext context, if_statement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     index_type returns index_type
	 *
	 * Constraint:
	 *     simple_type=simple_type
	 */
	protected void sequence_index_type(ISerializationContext context, index_type semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PascalPackage.Literals.INDEX_TYPE__SIMPLE_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalPackage.Literals.INDEX_TYPE__SIMPLE_TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIndex_typeAccess().getSimple_typeSimple_typeParserRuleCall_0(), semanticObject.getSimple_type());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     initial_expression returns initial_expression
	 *
	 * Constraint:
	 *     expression=expression
	 */
	protected void sequence_initial_expression(ISerializationContext context, initial_expression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PascalPackage.Literals.INITIAL_EXPRESSION__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalPackage.Literals.INITIAL_EXPRESSION__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getInitial_expressionAccess().getExpressionExpressionParserRuleCall_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     integer_number returns integer_number
	 *
	 * Constraint:
	 *     digit_sequence=digit_sequence
	 */
	protected void sequence_integer_number(ISerializationContext context, integer_number semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PascalPackage.Literals.INTEGER_NUMBER__DIGIT_SEQUENCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalPackage.Literals.INTEGER_NUMBER__DIGIT_SEQUENCE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getInteger_numberAccess().getDigit_sequenceDigit_sequenceParserRuleCall_0(), semanticObject.getDigit_sequence());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     label_declaration_part returns label_declaration_part
	 *
	 * Constraint:
	 *     (label+=label label+=label*)
	 */
	protected void sequence_label_declaration_part(ISerializationContext context, label_declaration_part semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     label returns label
	 *
	 * Constraint:
	 *     integer_number=integer_number
	 */
	protected void sequence_label(ISerializationContext context, label semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PascalPackage.Literals.LABEL__INTEGER_NUMBER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalPackage.Literals.LABEL__INTEGER_NUMBER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLabelAccess().getInteger_numberInteger_numberParserRuleCall_0(), semanticObject.getInteger_number());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     lower_bound returns lower_bound
	 *
	 * Constraint:
	 *     constant=constant
	 */
	protected void sequence_lower_bound(ISerializationContext context, lower_bound semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PascalPackage.Literals.LOWER_BOUND__CONSTANT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalPackage.Literals.LOWER_BOUND__CONSTANT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLower_boundAccess().getConstantConstantParserRuleCall_0(), semanticObject.getConstant());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     number returns number
	 *
	 * Constraint:
	 *     (integer_number=integer_number | real_number=real_number)
	 */
	protected void sequence_number(ISerializationContext context, number semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ordinal_type_identifier returns ordinal_type_identifier
	 *
	 * Constraint:
	 *     type_identifier=type_identifier
	 */
	protected void sequence_ordinal_type_identifier(ISerializationContext context, ordinal_type_identifier semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PascalPackage.Literals.ORDINAL_TYPE_IDENTIFIER__TYPE_IDENTIFIER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalPackage.Literals.ORDINAL_TYPE_IDENTIFIER__TYPE_IDENTIFIER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOrdinal_type_identifierAccess().getType_identifierType_identifierParserRuleCall_0(), semanticObject.getType_identifier());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     packed_conformant_array_schema returns packed_conformant_array_schema
	 *
	 * Constraint:
	 *     (bound_specification=bound_specification type_identifier=type_identifier)
	 */
	protected void sequence_packed_conformant_array_schema(ISerializationContext context, packed_conformant_array_schema semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PascalPackage.Literals.PACKED_CONFORMANT_ARRAY_SCHEMA__BOUND_SPECIFICATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalPackage.Literals.PACKED_CONFORMANT_ARRAY_SCHEMA__BOUND_SPECIFICATION));
			if (transientValues.isValueTransient(semanticObject, PascalPackage.Literals.PACKED_CONFORMANT_ARRAY_SCHEMA__TYPE_IDENTIFIER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalPackage.Literals.PACKED_CONFORMANT_ARRAY_SCHEMA__TYPE_IDENTIFIER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPacked_conformant_array_schemaAccess().getBound_specificationBound_specificationParserRuleCall_3_0(), semanticObject.getBound_specification());
		feeder.accept(grammarAccess.getPacked_conformant_array_schemaAccess().getType_identifierType_identifierParserRuleCall_6_0(), semanticObject.getType_identifier());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     parameter_type returns parameter_type
	 *
	 * Constraint:
	 *     (type_identifier=type_identifier | conformant_array_schema=conformant_array_schema)
	 */
	protected void sequence_parameter_type(ISerializationContext context, parameter_type semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     pointer_type returns pointer_type
	 *
	 * Constraint:
	 *     type_identifier=type_identifier
	 */
	protected void sequence_pointer_type(ISerializationContext context, pointer_type semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PascalPackage.Literals.POINTER_TYPE__TYPE_IDENTIFIER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalPackage.Literals.POINTER_TYPE__TYPE_IDENTIFIER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPointer_typeAccess().getType_identifierType_identifierParserRuleCall_1_0(), semanticObject.getType_identifier());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     procedure_block returns procedure_block
	 *
	 * Constraint:
	 *     (declaration_part=declaration_part statement_part=statement_part)
	 */
	protected void sequence_procedure_block(ISerializationContext context, procedure_block semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PascalPackage.Literals.PROCEDURE_BLOCK__DECLARATION_PART) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalPackage.Literals.PROCEDURE_BLOCK__DECLARATION_PART));
			if (transientValues.isValueTransient(semanticObject, PascalPackage.Literals.PROCEDURE_BLOCK__STATEMENT_PART) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalPackage.Literals.PROCEDURE_BLOCK__STATEMENT_PART));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getProcedure_blockAccess().getDeclaration_partDeclaration_partParserRuleCall_0_0(), semanticObject.getDeclaration_part());
		feeder.accept(grammarAccess.getProcedure_blockAccess().getStatement_partStatement_partParserRuleCall_1_0(), semanticObject.getStatement_part());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     procedure_body returns procedure_body
	 *
	 * Constraint:
	 *     procedure_block=procedure_block
	 */
	protected void sequence_procedure_body(ISerializationContext context, procedure_body semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PascalPackage.Literals.PROCEDURE_BODY__PROCEDURE_BLOCK) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalPackage.Literals.PROCEDURE_BODY__PROCEDURE_BLOCK));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getProcedure_bodyAccess().getProcedure_blockProcedure_blockParserRuleCall_0(), semanticObject.getProcedure_block());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     procedure_heading returns procedure_heading
	 *
	 * Constraint:
	 *     (identifier=identifier formal_parameter_list=formal_parameter_list?)
	 */
	protected void sequence_procedure_heading(ISerializationContext context, procedure_heading semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     procedure_identification returns procedure_identification
	 *
	 * Constraint:
	 *     identifier=identifier
	 */
	protected void sequence_procedure_identification(ISerializationContext context, procedure_identification semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PascalPackage.Literals.PROCEDURE_IDENTIFICATION__IDENTIFIER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalPackage.Literals.PROCEDURE_IDENTIFICATION__IDENTIFIER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getProcedure_identificationAccess().getIdentifierIdentifierParserRuleCall_1_0(), semanticObject.getIdentifier());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     procedure_parameter_section returns procedure_parameter_section
	 *
	 * Constraint:
	 *     procedure_heading=procedure_heading
	 */
	protected void sequence_procedure_parameter_section(ISerializationContext context, procedure_parameter_section semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PascalPackage.Literals.PROCEDURE_PARAMETER_SECTION__PROCEDURE_HEADING) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalPackage.Literals.PROCEDURE_PARAMETER_SECTION__PROCEDURE_HEADING));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getProcedure_parameter_sectionAccess().getProcedure_headingProcedure_headingParserRuleCall_0(), semanticObject.getProcedure_heading());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     procedure_statement returns procedure_statement
	 *
	 * Constraint:
	 *     (procedure_identifier=identifier actual_parameter_list=actual_parameter_list?)
	 */
	protected void sequence_procedure_statement(ISerializationContext context, procedure_statement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     program_heading returns program_heading
	 *
	 * Constraint:
	 *     (identifier=ID identifier_list=identifier_list)
	 */
	protected void sequence_program_heading(ISerializationContext context, program_heading semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PascalPackage.Literals.PROGRAM_HEADING__IDENTIFIER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalPackage.Literals.PROGRAM_HEADING__IDENTIFIER));
			if (transientValues.isValueTransient(semanticObject, PascalPackage.Literals.PROGRAM_HEADING__IDENTIFIER_LIST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalPackage.Literals.PROGRAM_HEADING__IDENTIFIER_LIST));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getProgram_headingAccess().getIdentifierIDTerminalRuleCall_1_0(), semanticObject.getIdentifier());
		feeder.accept(grammarAccess.getProgram_headingAccess().getIdentifier_listIdentifier_listParserRuleCall_3_0(), semanticObject.getIdentifier_list());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     program returns program
	 *
	 * Constraint:
	 *     (program_heading=program_heading block=block)?
	 */
	protected void sequence_program(ISerializationContext context, program semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     real_number returns real_number
	 *
	 * Constraint:
	 *     (
	 *         (digit_sequence=digit_sequence digit_sequence2=digit_sequence? scale_factor=scale_factor?) | 
	 *         (digit_sequence=digit_sequence scale_factor=scale_factor)
	 *     )
	 */
	protected void sequence_real_number(ISerializationContext context, real_number semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     record_section returns record_section
	 *
	 * Constraint:
	 *     (identifier_list=identifier_list type=type)
	 */
	protected void sequence_record_section(ISerializationContext context, record_section semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PascalPackage.Literals.RECORD_SECTION__IDENTIFIER_LIST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalPackage.Literals.RECORD_SECTION__IDENTIFIER_LIST));
			if (transientValues.isValueTransient(semanticObject, PascalPackage.Literals.RECORD_SECTION__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalPackage.Literals.RECORD_SECTION__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRecord_sectionAccess().getIdentifier_listIdentifier_listParserRuleCall_0_0(), semanticObject.getIdentifier_list());
		feeder.accept(grammarAccess.getRecord_sectionAccess().getTypeTypeParserRuleCall_2_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     record_type returns record_type
	 *
	 * Constraint:
	 *     field_list=field_list
	 */
	protected void sequence_record_type(ISerializationContext context, record_type semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PascalPackage.Literals.RECORD_TYPE__FIELD_LIST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalPackage.Literals.RECORD_TYPE__FIELD_LIST));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRecord_typeAccess().getField_listField_listParserRuleCall_1_0(), semanticObject.getField_list());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     repeat_statement returns repeat_statement
	 *
	 * Constraint:
	 *     (statement_sequence=statement_sequence expression=expression)
	 */
	protected void sequence_repeat_statement(ISerializationContext context, repeat_statement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PascalPackage.Literals.REPEAT_STATEMENT__STATEMENT_SEQUENCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalPackage.Literals.REPEAT_STATEMENT__STATEMENT_SEQUENCE));
			if (transientValues.isValueTransient(semanticObject, PascalPackage.Literals.REPEAT_STATEMENT__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalPackage.Literals.REPEAT_STATEMENT__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRepeat_statementAccess().getStatement_sequenceStatement_sequenceParserRuleCall_1_0(), semanticObject.getStatement_sequence());
		feeder.accept(grammarAccess.getRepeat_statementAccess().getExpressionExpressionParserRuleCall_3_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     repetitive_statement returns repetitive_statement
	 *
	 * Constraint:
	 *     (while_statement=while_statement | repeat_statement=repeat_statement | for_statement=for_statement)
	 */
	protected void sequence_repetitive_statement(ISerializationContext context, repetitive_statement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     result_type returns result_type
	 *
	 * Constraint:
	 *     type_identifier=type_identifier
	 */
	protected void sequence_result_type(ISerializationContext context, result_type semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PascalPackage.Literals.RESULT_TYPE__TYPE_IDENTIFIER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalPackage.Literals.RESULT_TYPE__TYPE_IDENTIFIER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getResult_typeAccess().getType_identifierType_identifierParserRuleCall_0(), semanticObject.getType_identifier());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     scale_factor returns scale_factor
	 *
	 * Constraint:
	 *     (sign=sign? digit_sequence=digit_sequence)
	 */
	protected void sequence_scale_factor(ISerializationContext context, scale_factor semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     set returns set
	 *
	 * Constraint:
	 *     element_list=element_list
	 */
	protected void sequence_set(ISerializationContext context, set semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PascalPackage.Literals.SET__ELEMENT_LIST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalPackage.Literals.SET__ELEMENT_LIST));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSetAccess().getElement_listElement_listParserRuleCall_1_0(), semanticObject.getElement_list());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     set_type returns set_type
	 *
	 * Constraint:
	 *     base_type=base_type
	 */
	protected void sequence_set_type(ISerializationContext context, set_type semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PascalPackage.Literals.SET_TYPE__BASE_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalPackage.Literals.SET_TYPE__BASE_TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSet_typeAccess().getBase_typeBase_typeParserRuleCall_2_0(), semanticObject.getBase_type());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     simple_expression returns simple_expression
	 *
	 * Constraint:
	 *     (sign=sign? term+=term (addition_operator+=addition_operator term+=term)*)
	 */
	protected void sequence_simple_expression(ISerializationContext context, simple_expression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     simple_statement returns simple_statement
	 *
	 * Constraint:
	 *     (assignment_statement=assignment_statement | procedure_statement=procedure_statement | goto_statement=goto_statement)?
	 */
	protected void sequence_simple_statement(ISerializationContext context, simple_statement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     simple_type returns simple_type
	 *
	 * Constraint:
	 *     (subrange_type=subrange_type | enumerated_type=enumerated_type)
	 */
	protected void sequence_simple_type(ISerializationContext context, simple_type semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     statement_part returns statement_part
	 *
	 * Constraint:
	 *     statement_sequence=statement_sequence
	 */
	protected void sequence_statement_part(ISerializationContext context, statement_part semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PascalPackage.Literals.STATEMENT_PART__STATEMENT_SEQUENCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalPackage.Literals.STATEMENT_PART__STATEMENT_SEQUENCE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStatement_partAccess().getStatement_sequenceStatement_sequenceParserRuleCall_1_0(), semanticObject.getStatement_sequence());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     statement_sequence returns statement_sequence
	 *
	 * Constraint:
	 *     (statement+=statement statement+=statement*)
	 */
	protected void sequence_statement_sequence(ISerializationContext context, statement_sequence semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     statement returns statement
	 *
	 * Constraint:
	 *     (label=label? (simple_statement=simple_statement | structured_statement=structured_statement))
	 */
	protected void sequence_statement(ISerializationContext context, statement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     string_character returns string_character
	 *
	 * Constraint:
	 *     any_character_except_quote=any_character_except_quote
	 */
	protected void sequence_string_character(ISerializationContext context, string_character semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PascalPackage.Literals.STRING_CHARACTER__ANY_CHARACTER_EXCEPT_QUOTE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalPackage.Literals.STRING_CHARACTER__ANY_CHARACTER_EXCEPT_QUOTE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getString_characterAccess().getAny_character_except_quoteAny_character_except_quoteParserRuleCall_0_1_0(), semanticObject.getAny_character_except_quote());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     strings returns strings
	 *
	 * Constraint:
	 *     (string_character+=string_character string_character+=string_character*)
	 */
	protected void sequence_strings(ISerializationContext context, strings semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     structured_statement returns structured_statement
	 *
	 * Constraint:
	 *     (
	 *         compound_statement=compound_statement | 
	 *         repetitive_statement=repetitive_statement | 
	 *         conditional_statement=conditional_statement | 
	 *         with_statement=with_statement
	 *     )
	 */
	protected void sequence_structured_statement(ISerializationContext context, structured_statement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     structured_type returns structured_type
	 *
	 * Constraint:
	 *     unpacked_structured_type=unpacked_structured_type
	 */
	protected void sequence_structured_type(ISerializationContext context, structured_type semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PascalPackage.Literals.STRUCTURED_TYPE__UNPACKED_STRUCTURED_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalPackage.Literals.STRUCTURED_TYPE__UNPACKED_STRUCTURED_TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStructured_typeAccess().getUnpacked_structured_typeUnpacked_structured_typeParserRuleCall_1_0(), semanticObject.getUnpacked_structured_type());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     subrange_type returns subrange_type
	 *
	 * Constraint:
	 *     (lower_bound=lower_bound upper_bound=upper_bound)
	 */
	protected void sequence_subrange_type(ISerializationContext context, subrange_type semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PascalPackage.Literals.SUBRANGE_TYPE__LOWER_BOUND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalPackage.Literals.SUBRANGE_TYPE__LOWER_BOUND));
			if (transientValues.isValueTransient(semanticObject, PascalPackage.Literals.SUBRANGE_TYPE__UPPER_BOUND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalPackage.Literals.SUBRANGE_TYPE__UPPER_BOUND));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSubrange_typeAccess().getLower_boundLower_boundParserRuleCall_0_0(), semanticObject.getLower_bound());
		feeder.accept(grammarAccess.getSubrange_typeAccess().getUpper_boundUpper_boundParserRuleCall_2_0(), semanticObject.getUpper_bound());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     tag_field returns tag_field
	 *
	 * Constraint:
	 *     identifier=identifier?
	 */
	protected void sequence_tag_field(ISerializationContext context, tag_field semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     term returns term
	 *
	 * Constraint:
	 *     (factor+=factor (multiplication_operator+=multiplication_operator factor+=factor)*)
	 */
	protected void sequence_term(ISerializationContext context, term semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     type_definition_part returns type_definition_part
	 *
	 * Constraint:
	 *     (type_definition+=type_definition type_definition+=type_definition*)
	 */
	protected void sequence_type_definition_part(ISerializationContext context, type_definition_part semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     type_definition returns type_definition
	 *
	 * Constraint:
	 *     (identifier=identifier type=type)
	 */
	protected void sequence_type_definition(ISerializationContext context, type_definition semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PascalPackage.Literals.TYPE_DEFINITION__IDENTIFIER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalPackage.Literals.TYPE_DEFINITION__IDENTIFIER));
			if (transientValues.isValueTransient(semanticObject, PascalPackage.Literals.TYPE_DEFINITION__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalPackage.Literals.TYPE_DEFINITION__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getType_definitionAccess().getIdentifierIdentifierParserRuleCall_0_0(), semanticObject.getIdentifier());
		feeder.accept(grammarAccess.getType_definitionAccess().getTypeTypeParserRuleCall_2_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     type_identifier returns type_identifier
	 *
	 * Constraint:
	 *     identifier=identifier
	 */
	protected void sequence_type_identifier(ISerializationContext context, type_identifier semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PascalPackage.Literals.TYPE_IDENTIFIER__IDENTIFIER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalPackage.Literals.TYPE_IDENTIFIER__IDENTIFIER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getType_identifierAccess().getIdentifierIdentifierParserRuleCall_0(), semanticObject.getIdentifier());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     type returns type
	 *
	 * Constraint:
	 *     (simple_type=simple_type | structured_type=structured_type | pointer_type=pointer_type | type_identifier=type_identifier)
	 */
	protected void sequence_type(ISerializationContext context, type semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     unpacked_conformant_array_schema returns unpacked_conformant_array_schema
	 *
	 * Constraint:
	 *     (
	 *         bound_specification+=bound_specification 
	 *         bound_specification+=bound_specification* 
	 *         (type_identifier=type_identifier | conformant_array_schema=conformant_array_schema)
	 *     )
	 */
	protected void sequence_unpacked_conformant_array_schema(ISerializationContext context, unpacked_conformant_array_schema semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     unpacked_structured_type returns unpacked_structured_type
	 *
	 * Constraint:
	 *     (array_type=array_type | record_type=record_type | set_type=set_type | file_type=file_type)
	 */
	protected void sequence_unpacked_structured_type(ISerializationContext context, unpacked_structured_type semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     upper_bound returns upper_bound
	 *
	 * Constraint:
	 *     constant=constant
	 */
	protected void sequence_upper_bound(ISerializationContext context, upper_bound semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PascalPackage.Literals.UPPER_BOUND__CONSTANT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalPackage.Literals.UPPER_BOUND__CONSTANT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUpper_boundAccess().getConstantConstantParserRuleCall_0(), semanticObject.getConstant());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     value_parameter_section returns value_parameter_section
	 *
	 * Constraint:
	 *     (identifier_list=identifier_list parameter_type=parameter_type)
	 */
	protected void sequence_value_parameter_section(ISerializationContext context, value_parameter_section semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PascalPackage.Literals.VALUE_PARAMETER_SECTION__IDENTIFIER_LIST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalPackage.Literals.VALUE_PARAMETER_SECTION__IDENTIFIER_LIST));
			if (transientValues.isValueTransient(semanticObject, PascalPackage.Literals.VALUE_PARAMETER_SECTION__PARAMETER_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalPackage.Literals.VALUE_PARAMETER_SECTION__PARAMETER_TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getValue_parameter_sectionAccess().getIdentifier_listIdentifier_listParserRuleCall_0_0(), semanticObject.getIdentifier_list());
		feeder.accept(grammarAccess.getValue_parameter_sectionAccess().getParameter_typeParameter_typeParserRuleCall_2_0(), semanticObject.getParameter_type());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     variable_declaration_part returns variable_declaration_part
	 *
	 * Constraint:
	 *     (variable_declaration+=variable_declaration variable_declaration+=variable_declaration*)
	 */
	protected void sequence_variable_declaration_part(ISerializationContext context, variable_declaration_part semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     variable_declaration returns variable_declaration
	 *
	 * Constraint:
	 *     (identifier_list=identifier_list type=type)
	 */
	protected void sequence_variable_declaration(ISerializationContext context, variable_declaration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PascalPackage.Literals.VARIABLE_DECLARATION__IDENTIFIER_LIST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalPackage.Literals.VARIABLE_DECLARATION__IDENTIFIER_LIST));
			if (transientValues.isValueTransient(semanticObject, PascalPackage.Literals.VARIABLE_DECLARATION__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalPackage.Literals.VARIABLE_DECLARATION__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVariable_declarationAccess().getIdentifier_listIdentifier_listParserRuleCall_0_0(), semanticObject.getIdentifier_list());
		feeder.accept(grammarAccess.getVariable_declarationAccess().getTypeTypeParserRuleCall_2_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     variable_parameter_section returns variable_parameter_section
	 *
	 * Constraint:
	 *     (identifier_list=identifier_list parameter_type=parameter_type)
	 */
	protected void sequence_variable_parameter_section(ISerializationContext context, variable_parameter_section semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PascalPackage.Literals.VARIABLE_PARAMETER_SECTION__IDENTIFIER_LIST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalPackage.Literals.VARIABLE_PARAMETER_SECTION__IDENTIFIER_LIST));
			if (transientValues.isValueTransient(semanticObject, PascalPackage.Literals.VARIABLE_PARAMETER_SECTION__PARAMETER_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalPackage.Literals.VARIABLE_PARAMETER_SECTION__PARAMETER_TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVariable_parameter_sectionAccess().getIdentifier_listIdentifier_listParserRuleCall_1_0(), semanticObject.getIdentifier_list());
		feeder.accept(grammarAccess.getVariable_parameter_sectionAccess().getParameter_typeParameter_typeParserRuleCall_3_0(), semanticObject.getParameter_type());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     variable returns variable
	 *
	 * Constraint:
	 *     (entire_variable=entire_variable expression_list+=expression_list* field_identifier+=identifier*)
	 */
	protected void sequence_variable(ISerializationContext context, variable semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     variant_part returns variant_part
	 *
	 * Constraint:
	 *     (tag_field=tag_field type_identifier=type_identifier variant+=variant variant+=variant*)
	 */
	protected void sequence_variant_part(ISerializationContext context, variant_part semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     variant returns variant
	 *
	 * Constraint:
	 *     (case_label_list=case_label_list field_list=field_list)
	 */
	protected void sequence_variant(ISerializationContext context, variant semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PascalPackage.Literals.VARIANT__CASE_LABEL_LIST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalPackage.Literals.VARIANT__CASE_LABEL_LIST));
			if (transientValues.isValueTransient(semanticObject, PascalPackage.Literals.VARIANT__FIELD_LIST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalPackage.Literals.VARIANT__FIELD_LIST));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVariantAccess().getCase_label_listCase_label_listParserRuleCall_0_0(), semanticObject.getCase_label_list());
		feeder.accept(grammarAccess.getVariantAccess().getField_listField_listParserRuleCall_3_0(), semanticObject.getField_list());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     while_statement returns while_statement
	 *
	 * Constraint:
	 *     (expression=expression statement=statement)
	 */
	protected void sequence_while_statement(ISerializationContext context, while_statement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PascalPackage.Literals.WHILE_STATEMENT__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalPackage.Literals.WHILE_STATEMENT__EXPRESSION));
			if (transientValues.isValueTransient(semanticObject, PascalPackage.Literals.WHILE_STATEMENT__STATEMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalPackage.Literals.WHILE_STATEMENT__STATEMENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getWhile_statementAccess().getExpressionExpressionParserRuleCall_1_0(), semanticObject.getExpression());
		feeder.accept(grammarAccess.getWhile_statementAccess().getStatementStatementParserRuleCall_3_0(), semanticObject.getStatement());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     with_statement returns with_statement
	 *
	 * Constraint:
	 *     (variable+=variable variable+=variable* statement=statement)
	 */
	protected void sequence_with_statement(ISerializationContext context, with_statement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
